%----------------------------------------------------------------------------
\chapter{Tesztelés, hibajavítás}
%----------------------------------------------------------------------------

A feladat hátralevõ részében az elkészült hardver-elemek tesztelésével, az esetleges hibák felderítésével és azok kijavításával foglalkoztam.

\section{Az interfészpanel tesztje}
Miután megérkezett a gyártásból az interfészpanel amit terveztem, elvégeztem az alkatrészek beforrasztását, és egy példaprojektet készítettem abból a célból, hogy magának a panelnek a mûködését ellenõrizni tudjam. Ehhez elkészítettem az FPGA-panel tüskesorának hozzárendelését a verilog-modul jeleihez egy UCF-fájl segítségével. Az interfészpanel 5V-os jeleire egy próbapanel segítségével LED-eket illesztettem, melyeket a tesztprojektben sorban egymás után villantottam fel, így megbizonyosodhattam a szintillesztõ áramkör helyes mûködésérõl. Ekkor vettem észre azt is, hogy a meghajtó foglaltságát jelzõ zöld színû státuszjelzõ LED-et fordított polaritással forrasztottam rá az interfészpanelre, mivel az alkatrészen megtévesztõ módon szerepelt a polaritásmegjelölés - így ezt kijavítottam.

A lábkiosztás megtervezésekor törekedtem arra, hogy az FPGA panel olyan lábait használjam, melyeknek nincs alternatív funkciója, ezzel csökkentve annak a valószínûségét, hogy a fejleszõpanelen található áramköri elemek vagy perifériák módosítják az áramköröm tervezett viselkedését. A teszt során nyilvánvalóvá vált, hogy az FPGA-panel specifikációjától eltérõ módon a P11-es lábnak más funkciója is van, mégpedig az integrált soros port TX vonalát is ez táplálja. Mivel ez nincs használatban szerencsére nem okozott gondot, csak bosszantó, hogy világít az alaplapon egy extra led, valamint ezek után kevésbé megbízható dolog pusztán a dokumentációkra támaszkodni.

\begin{figure}[!ht]
\centering
\includegraphics[width=120mm, keepaspectratio]{figures/fpga_tx.png}
\caption{Eltérés a fejlesztõpanel kapcsolási rajza és a valóság között.}
\label{fig:pinout_fukdup}
\end{figure}

\section{Verilog-modulok}
Elõször a saját készítésû verilog-modulokhoz készítettem külön-külön tesztkörnyezeteket, és mûködésüket az ISE szimulátora segítségével végeztem. Elõször az órajel-generátort, majd a memória-modulokat teszteltem, végül pedig egy olyan összeállítást is elkészítettem, ahol a RAM és a ROM is a rendszer buszaira kapcsolódik, és ellenõriztem az engedélyezõ logikát valamint azt, hogy a megfelelõ memóriacímek használatakor nem hajtanak-e szembe.

Mivel úgy tûnt, hogy helyesen mûködnek ezek a modulok, elkezdtem a rendszer többi részének integrációját, egyesével vettem hozzá a projekthez a processzor, a CIA és a floppy vezérlõ implementációjának egy-egy példányait.

\section{A firmware}
Miután a processzor is bekerült a top modulba, a tesztelést a ROM-ba betöltött firmware bináris segítségével végeztem: a processzor ekkor már az eredeti 1581-es meghajtóra készült kódott futtatta, így biztos lehettem benne, hogy a szoftverben nincs hiba. A bináris állományt már csak azért sem lett volna érdemes piszkálni, mivel tartalmaz egy ellenõrzõösszeget is, amivel a program indulásakor a ROM tartalmának sértetlenségét ellenõrzi. Érdekes tapasztalat volt úgy fejleszteni, hogy egy hibamentes, kész szoftver alatt kellett megvalósítani azt a hardvert, mely az eredeti specifikációnak megfelelõ mûködést hivatott biztosítani.

További nehézséget jelentett, hogy magának a firmware-nek a mûködése csak az eredeti, assemblyben megírt forrásfájlok kommentjeibõl, valamint egy német nyelven kommentezett dissassembly listing fájlból volt kideríthetõ.\cite{nemet_disassembly} Természetesen a 1581-es meghajtó felhasználói kézikönyvében számos információ utal arra, hogyan kell mûködnie bizonyos esetekben a meghajtónak, a részletes okokat csak a hardver és a firmware átfogó ismeretében lehet tudni.

A szimulátor segítségével nyomon követhetõ volt a program futása, az FPGA-panel IO lábai mellé a processzor és a rendszer belsõ jeleit is felvettem a megjelenített hullámformák közé, így láthatóvá váltak a buszmûveletek, a programszámláló és a különbözõ regiszterek értékei is. A program futása során elõször különbözõ hardveres teszteket hajt végre: inicializálja a perifériákat, leellenõrzi a ROM sértetlenségét az ellenõrzõösszeg alapján, különbözõ értékekkel tölti fel a RAM-ot majd vissza is olvassa azokat. Az ekkor fellépõ hibajelenségeket a hiba okától függõen a visszajelzõ LED-ek megadott számú felvillanásával lehet azonosítani.

Miután lefutottak a tesztek, elalszik a 'Drive' feliratú státusz visszajelzõ LED, és a firmware elindít egy operációs rendszert. Az ütemezõt az interfész adapter Timer B idõzítõje hívja meg, másodpercenként 100-szor. Az operációs rendszer prioritásokkal megadott JOB-okat futtat, egyszerre legfeljebb 8-at képes nyilvántartani. Futáskor a JOB kódokat a prioritásuknak megfelelõ sorrendben fix memóriacímeken tárolja, a feladat befejezésekor pedig a visszatéréskor adott kód (hibakód) kerül a helyére.

A szimuláció kezdeti szakasza alapján mûködni látszott a processzor, így megpróbáltam az FPGA-ra szintetizálva is kipróbálni a rendszert. Azt tapasztaltam, hogy sosem aludt el a zöld LED, és valóban nem is jutott túl az inicializálási állapoton a meghajtó. Mivel a hardveren nem állt rendelkezésre debugolásra vagy legalábbis a program futásának nyomon követésére alkalmas interfész, visszatértem a szimulációhoz. Hosszabb ideig futtatva azt, kiderült, hogy végtelen ciklusba kerül a program és egy olyan változó értékének 0-ra csökkenésére vár, amelyet a program további futása során nem módosít semmi.

Az assembly listing alapján kiderítettem, hogy a szóban forgó változó egy szoftveres várakozáshoz használt számláló, melynek értékét az idõzítõ lejártával kiszolgálásra kerülõ megszakításrutin csökkenti eggyel. A probléma, hogy nem jut sose érvényre ez a megszakítás. Mivel a jelenség okának felderítéséhez ezen a ponton már nem volt kényelmes pusztán a szimulátor környezetben vizsgált jelek alapján kitalálni, mi okozza a program futásában fellépõ eltérést (annak tudatában, hogy a program viszont biztosan jól mûködne egy hibamentes hardveren), más megközelítéssel próbálkoztam.

\section{Emulátor}
Az ugró utasítások és ciklusok nyomon követése nagyon megnehezítette a debugolást, mivel az ISIM programban csak lineárisan követhetõ a program futása. Ráadásul a memória tartalma csak a szimuláció végével elért állapotot tükrözi, a kurzorok állításával nem kérdezhetõ le a szimuláció egy korábbi idõpontjához tartozó állapot. Emiatt a változók és a stack tartalmának vizsgálata, valamint az eltérések észrevétele csak egy újabb szimuláció segítségével volt megtehetõ, ami viszont jelentõsen megnövelte a hibakereséssel töltött idõt.

Ahhoz, hogy egyáltalán a program futásának nyomon követését hatékonyabban tudjam végezni, írtam egy emulátor programot C-ben, mely a rendszer funkcionális mûködésének megfelelõen viselkedik. Léteznek ugyan online elérhetõ 6502-es processzorhoz készült disassembler és emulátor eszközök, melyek viszont elsõsorban demonstrációs célúak, így nem bõvíthetõk vagy fejleszthetõk tetszõlegesen. Az emulátor elkészítéséhez mindenképp szükséges volt megismernem a 6502-es processzor belsõ felépítését és mûködését, utasításkészletét, címzési módjait, és hogy melyik mûvelet milyen egyéb belsõ állapotokat változtat meg. Ebben segítségemre volt a 6502-es processzor programozói kézikönyve\cite{programming_manual}, valamint az utasításkészlet online példákkal kiegészített interaktívan kereshetõ változata.\cite{instruction_set}

Az emulátor program ugyanazt a bináris állományt futtatja, mint amit a ROM-ba is betöltöttem, sõt felépítését tekintve a verilog-ban leírt rendszert tükrözi azzal az eltéréssel, hogy minden perifériához mint memória fér hozzá, a róluk beolvasott értékeket pedig az olvasás pillanatában állítottam elõ a valóságnak (és a szimulációnak) megfelelõ módon.

Az emulátor segítségével tehetõk a programba töréspontok, de másmilyen típusú feltétel esetén megállítható a program futása, és szemléletes módon megtekinthetõ a stack vagy a zero-page tartalma, hasonlóképp a CPU és a többi periféria regisztereié is. A hardveres megszakítás-kéréseket szintén a szimuláció és a kiváltó okok ismeretében az emulátorban szoftveresen valósítottam meg.

Az emulátor, a listing fájl, valamint papír és ceruza használatával sikerült visszakövetnem, hogy a kívánt állapot elérési láncában hol megy félre a program, és milyen értékek stack-re kerülésének köszönhetõ, hogy ez megtörténik.

Kiderült, hogy a processzor verilog-moduljában hibás a szoftveres megszakítást jelzõ flag implementációja, ugyanis a specifikációtól eltérõ módon akkor is ugyanolyan értékkel kerül fel a stack-re ha hardveres megszakítás érkezik, mintha szoftveres. Fontos megjegyezni, hogy a státuszregiszterben nem változik meg sosem ennek a flag-nek az állapota, csak a megszakítás érvényre jutásakor kerül beállításra a státuszregiszter stack-re kerülõ másolatában.

Miután megkerestem és javítottam a hibát a processzormag leírásában, a meghajtó sikeresen el tudta végezni a inicializációt a szimuláció szerint, és a valóságban is.

\section{Tesztelés valódi környezetben}
Ettõl kezdve a meghajtó eseményvezérelt mûködését feltételeztem, így nem szimulátor vagy emulátor segítségével, hanem egy valódi, Commodore 64-es számítógéppel, PC-s floppy meghajtóval kiegészített tesztkörnyezetben figyeltem meg az FPGA-panel mûködését. A vezetékeken jelen lévõ jelszinteket egy Digilent Analog Discovery 2 típusú mûszer 16 csatornás logikai analizátor funkciója segítségével mértem. A logikai analizátort úgy kapcsoltam a rendszerhez, hogy házilag kiegészítettem a floppy meghajtóhoz vezetõ szalagkábelt, és az interfészpanelt a számítógéppel összekötõ soros buszt egy-egy extra hüvelysorral.

A meghajtó bekapcsolásakor figyelmes lettem arra, hogy a hajlékonylemezt forgató motor egy adott ideig engedélyezõ parancsot kap majd leáll. Szimuláció szerint is ez a mûködés volt elvárható, viszont a floppy vezérlõ állapotgépét vizsgálva figyelmes lettem arra, hogy mintha nem megfelelõ állapotba kerülne a rendszer.

\begin{figure}[!ht]
\centering
\includegraphics[width=125mm, keepaspectratio]{figures/fdc_fail.png}
\caption{Szimuláció: a floppy-vezérlõ hibás állapot-átmenete}
\label{fig:fdc_fail}
\end{figure}

Az FDC-nek adatlapja szerint a 0xD0 (Force Interrupt) parancs hatására IDLE állapotban kellene maradnia, hiszen így történik meg a periféria alaphelyzetbe állítása, ehelyett INIT, majd SPINUP állapotba kerül. (Érdekességképp megjegyzem, hogy ezután a floppy-vezérlõ hat index-impulzus megérkezésére várakozik, hogy megbizonyosodjon arról, valóban forog a motor. Mivel azonban a floppy meghajtó motor engedélyezõ jele nem az FDC, hanem a CIA felõl van meghajtva, ez nem következik be. Helyette egy másik leállási feltétel lép érvénybe, timeout-ol a rendszer, majd hibajelzés nélkül folytatja a programvégrehajtást.)

A jelenség oka az volt, hogy az FDC command regiszter írása szinkron, viszont az állapotgép "aszinkron", és már a chip select hatására továbblép, nem várja meg, hogy érvényre jusson az újonnan beérkezõ parancs. Megoldást jelentett a problémára, hogy a command regiszter írását az órajelhez szinkronizáltam:

\begin{lstlisting}[language=vhdl,frame=single,float=!ht]
CMD_WR <= true when
 CSn = '0' and A1 = '0' and A0 = '0' and RWn = '0' and rising_edge(CLK)
else false; -- Command register write.
\end{lstlisting}

Másik, nagyobb horderejû probléma akkor jelentkezett, amikor megpróbáltam parancsokat küldeni a számítógéprõl a meghajtónak. A soros buszon zajló adatforgalom könnyebb olvashatósága kedvéért írtam egy szkriptet a logikai analizátor felhasználói felületéhez, mely a Commodore IEEE-488 protokoll-specfikáció szerint beérkezõ handhsake-jelek és adatbitek alapján állítja vissza az adatokat olvasható formátumú hexadecimális értékekké.

A Commodore számítógéprõl olyan parancsokat küldtem, melyek a floppy meghajtó mûködésének vizsgálatára alkalmasak: ilyen volt például a lemez formázása vagy a lemezen szereplõ fájlok kilistázása. Ez utóbbinak természetesen akkor van a gyakorlatban értelme, ha valóban egy megfelelõképp formázott lemez van a meghajtóban, viszont az én floppy lemezeim eredetileg IBM PC-ken való használat számára voltak megformázva. A Commodore 64-es számítógépen BASIC nyelven lehetséges programokat írni és parancsokat végrehajtani, így a lemezkezelés is ezek segítségével történt.

Például a buszon lévõ egyes eszközök megszólítására és az adott parancs elküldésére az \lstinline| OPEN15,8,15,"PARANCS":CLOSE15| szekvencia használható. A paraméterekben szereplõ számok rendre a (tetszõleges 8-bites) csatornaszám, a meghajtó azonosítója (8), és a másodlagos címe.\cite{manual} A kiadott parancs bájtonként kerül elküldésre, az adatfolyamot egy nyitó- és egy záró vezérlõkód keretezi.

\begin{table}[ht]
	\footnotesize
	\centering
	\caption{Az IEC-busz vezérlõkódjai} 
	\begin{tabular}{ | r | l |}
	\hline
	Kezdõcím & Parancs leírása és paraméterei\\ \hline
	\$20 & LISTEN + azonosító\\
	\$3F & UNLISTEN\\
	\$40 & TALK + azonosító\\
	\$5F & UNTALK\\
	\$60 & OPEN CHANNEL/DATA  + másodlagos cím\\
	\$E0 & CLOSE + másodlagos cím\\
	\$F0 & OPEN + másodlagos cím\\
	\hline
	\end{tabular}
	\label{tab:IEC_Commands}
\end{table}

\newpage
A soros kommunikáció tesztelése végett a felhasználó kézikönyvben javasolt programrészletet használtam. Ennek segítségével lekérdezhetõ a meghajtó aktuális állapota, kiolvasható az esetlegesen fennálló hibakód. Érdekesség, hogy a meghajtó bekapcsolása vagy újraindítása után hibakód helyett a firmware verzióját küldi vissza.

\begin{lstlisting}[frame=single,float=!ht]
10 OPEN15,8,15
20 INPUT#15,EN,EM$,ET,ES
30 PRINT EN,EM$,ET,ES
40 CLOSE15
RUN
\end{lstlisting}

Azt tapasztaltam, hogy a parancsot elküldi a számítógép a meghajtónak, viszont válaszként nem érkezik meg az elvárt \lstinline|73, "COPY RIGHT CBM DOS V10 1581"| szöveg, helyette lefagyott a meghajtó, és nem fogadott több parancsot a következõ újraindulásig. Kíváncsiságból elvégeztem egy referenciamérést egy SDrive64 1564 típusú, SD2IEC SD-kártya adapterhez hasonló periféria eszközzel, amivel tudtam tesztelni, milyen - protokollra jellemzõ magas szintû - válaszokat várhatok az FPGA-n megvalósított meghajtóról.

\begin{figure}[!ht]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/serial_diffs.png}
\caption{Eltérés a handshake-jelek között}
\label{fig:serial_diffs}
\end{figure}

A két esetben eltérést tapasztaltam, mégpedig a kommunikáció irányának megváltoztatására szolgáló handshake-jelek tekintetében. A floppy meghajtó nem húzza le a busz CLK vonalát, ellentétben a specifikációval és az SD-kártya olvasóval, mely az ábrán is látható.

Annak megkülönböztetésére, hogy az adott pillanatban melyik eszköz hajtja meg a kétirányú adat-és órajel vonalat, külön állapotjelzõ jelek kivezetése volt szükséges az FPGA-ról, melyeket az interfészpanel szabadon maradt lábaira illesztettem, és mértem a logikai analizátorral.

\begin{figure}[!ht]
\centering
\includegraphics[width=130mm, keepaspectratio]{figures/serial_stops_randomly.png}
\caption{Megszakad az adatfolyam}
\label{fig:serial_stops}
\end{figure}

Látható, hogy a Commodore 64 egyszer csak már nem húzza le a DATA vonalat. A nyilakkal jelölt helyen nem húzza le a vonalat a periféria (ez a DBG\_DATAIN jel segítségével ellenõrizhetõ), tehát a számítógépnek kellett volna vezérelnie az adatbuszt a specifikációnak megfelelõen. Látható tehát, hogy a parancsot sikeresen fogadta a meghajtó, és meg is kezdte a válasz elküldését, melyet viszont valamilyen ok folytán nem tudott befejezni.

Egy konzultáció során felmerült a gyanú, hogy esetleg nem megfelelõ órajel-frekvenciával hajtom meg a CIA-t, mivel a soros adatátvitelt az azon található Timer A periféria ütemezni. Ezt a mérési eredmények alá is támasztották. Elkerülte a figyelmem, hogy az FPGA panelen rendelkezésre álló órajelforrás 16MHz helyett 50MHz-es órajellel látja el a rendszert. Ugyan a soros busz szinkron adatátvitelt biztosít, a protokoll specifikáció tartalmaz olyan helyzeteket, melyek során kritikus betartani a pontos idõzítést.

A megoldás egyben egy feladatot is rejtett magában, ugyanis mivel az 50MHz nem egész számú többszöröse a 16MHz-nek, így egyszerû osztással nem lehet azt elõállítani belõle. Ehhez a Spartan 6 FPGA-ban található PLL modullal egészítettem ki az órajel-generátor verilog-modult, melyet az adatlapja alapján felkonfiguráltam és le is szimuláltam, mielõtt kipróbáltam a fizikai hardveren.\cite{pllconfig}

\begin{figure}[!ht]
\centering
\includegraphics[width=90mm, keepaspectratio]{figures/tv.jpg}
\caption{Sikeres státusz-kiolvasás eredménye a képernyõn}
\label{fig:tv}
\end{figure}

Ezzel a megoldással már helyesen mûködött a soros port, viszont a meghajtót még mindig nem sikerült rábírnom a lemez megformázására. A parancs megérkezik a meghajtóra, és látszólag el is indul a formázás folyamata, azonban miután az író-olvasó fej ahelyett, hogy a szélsõ sávra lépés után egyesével belépkedne a lemez belsõ része felé némi várakozás után teljes sebességgel középre mozog és ott is marad, ezután pedig ismételten nem lehet megszólítani a meghajtót.

\section{Záró gondolatok}
A féléves munka végeztével ezeket az eredményeket sikerült elérnem. Megpróbálkoztam még a formázás során ütemezésre kerülõ job mûködésének megismerésével, valamint a fej által írt/olvasott adatok dekódolására - a soros porthoz hasonlóan - készíteni egy szkriptet a logikai analizátor szoftveréhez. Idõ hiányában egyelõre nem jártam sikerrel.

Önálló laboratóriumi munkám során a méröki feladatok egy új perspektíváját ismertem meg, fõleg a reverse-engineering és a hardvertesztelés terén. További lehetõségnek fenntartom a 1581-es meghajtó befejezését, valamint a megszerzett tudás és tapasztalatok ismeretében hasonló témában tovább fejlõdni.